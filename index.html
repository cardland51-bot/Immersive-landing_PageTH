<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive Floating Ball</title>
<style>
body { margin:0; overflow:hidden; background: radial-gradient(#0a1a3a, #021028);}
canvas { touch-action:none; display:block;}
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let ball, velocity;
let touchX=0, touchY=0, touching=false;

const roomSize = 40;
const xLimit = 25;
const yLimit = roomSize/2 - 2;

init();
animate();

function init(){
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x114477, 0.015);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0,0,70);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x0a1a3a);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambient = new THREE.AmbientLight(0x88aaff,1.2);
    scene.add(ambient);
    const light = new THREE.PointLight(0x66bbff,2,150);
    light.position.set(0,0,50);
    scene.add(light);

    // Back wall
    const wallGeo = new THREE.PlaneGeometry(200,100);
    const wallMat = new THREE.MeshStandardMaterial({
        color:0x113366,
        emissive:0x003366,
        emissiveIntensity:0.4,
        metalness:0.2,
        roughness:0.8
    });
    const backWall = new THREE.Mesh(wallGeo, wallMat);
    backWall.position.z=-80;
    scene.add(backWall);

    // Grid floor
    const gridHelper = new THREE.GridHelper(200,40,0x66ccff,0x0099ff);
    gridHelper.material.opacity=0.6;
    gridHelper.material.transparent=true;
    gridHelper.rotation.x=Math.PI/2;
    gridHelper.position.z=-40;
    scene.add(gridHelper);

    // Floating ball
    const ballGeo = new THREE.SphereGeometry(1.8,32,32);
    const ballMat = new THREE.MeshStandardMaterial({
        emissive:0x33bbff,
        color:0x0088ff,
        emissiveIntensity:2.5,
        roughness:0.2
    });
    ball = new THREE.Mesh(ballGeo,ballMat);
    scene.add(ball);

    // Initial velocity
    velocity = new THREE.Vector3(0.25,0.18,0);

    // Touch / mouse controls
    window.addEventListener("touchstart",(e)=>{touching=true;});
    window.addEventListener("touchend",(e)=>{touching=false;});
    window.addEventListener("touchmove",(e)=>{
        touching=true;
        touchY = ((e.touches[0].clientY/window.innerHeight)-0.5)*-roomSize*1.8;
        touchX = ((e.touches[0].clientX/window.innerWidth)-0.5)*roomSize*1.5;
    });

    window.addEventListener("mousemove",(e)=>{
        touching=true;
        touchY = ((e.clientY/window.innerHeight)-0.5)*-roomSize*1.8;
        touchX = ((e.clientX/window.innerWidth)-0.5)*roomSize*1.5;
    });

    window.addEventListener("mouseleave",()=>{touching=false;});

    window.addEventListener("resize",()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth,window.innerHeight);
    });
}

function animate(){
    requestAnimationFrame(animate);

    if(touching){
        // Calculate difference to finger
        const dx = (touchX - ball.position.x) * 0.1;
        const dy = (touchY - ball.position.y) * 0.1;

        // Move ball
        ball.position.x += dx;
        ball.position.y += dy;

        // Update velocity to match movement for smooth release
        velocity.x = dx*0.8 + velocity.x*0.2;
        velocity.y = dy*0.8 + velocity.y*0.2;

    } else {
        // Normal floating motion
        ball.position.add(velocity);

        // Bounce off boundaries
        if(ball.position.x > xLimit || ball.position.x < -xLimit) velocity.x*=-1;
        if(ball.position.y > yLimit || ball.position.y < -yLimit) velocity.y*=-1;
    }

    // Camera follows ball smoothly
    camera.position.x += (ball.position.x*0.6 - camera.position.x)*0.05;
    camera.position.y += (ball.position.y*0.3 - camera.position.y)*0.05;
    camera.lookAt(ball.position);

    renderer.render(scene,camera);
}
</script>
</body>
</html>
