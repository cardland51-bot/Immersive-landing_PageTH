<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cyberpunk Neon Chamber</title>
<style>
body { margin:0; overflow:hidden; background: radial-gradient(#02020a, #000000);}
canvas { display:block; touch-action:none; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let ball, velocity, lastTouch=null, touching=false;
let activeIcon=null;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const icons = [];

const cubeWidth=200, cubeHeight=100, cubeDepth=400;
const xLimit=cubeWidth/2, yLimit=cubeHeight/2;
const friction=0.92, maxVelocity=3;
let camPos=new THREE.Vector3(0,0,150);
const defaultCamPos = camPos.clone();
const defaultLookAt = new THREE.Vector3(0,0,0);

// Smooth camera
let camTarget = camPos.clone();
let lookTarget = defaultLookAt.clone();
const camSmooth = 0.02;

// Click sound
const audio = new Audio("https://www.soundjay.com/button/sounds/button-10.mp3");

init();
animate();

function init(){
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.copy(camPos);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.setClearColor(0x000000);
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0x3311aa,1.2));
    const pointLight = new THREE.PointLight(0x33ccff,2.5,800);
    pointLight.position.set(0,0,200);
    scene.add(pointLight);

    // Neon cube edges
    const cubeGeo = new THREE.BoxGeometry(cubeWidth,cubeHeight,cubeDepth);
    const edges = new THREE.EdgesGeometry(cubeGeo);
    const line1 = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color:0x00ffff, linewidth:2}));
    scene.add(line1);
    const line2 = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color:0xff33ff, linewidth:1}));
    scene.add(line2);

    // Ball
    const ballGeo = new THREE.SphereGeometry(2.5,32,32);
    const ballMat = new THREE.MeshStandardMaterial({
        color:0x00ffff, metalness:0.9, roughness:0.05, emissive:0x33ccff, emissiveIntensity:2
    });
    ball = new THREE.Mesh(ballGeo, ballMat);
    scene.add(ball);
    ball.position.set(0,0,0);
    velocity = new THREE.Vector3(0,0,0);

    // Icon texture
    const iconLoader = new THREE.TextureLoader();
    const iconTexture = iconLoader.load('https://i.imgur.com/nl7tPK6.jpeg');

    // Back wall icons (fewer for clean look)
    const backIcons = [
        new THREE.Vector3(-40,10,-cubeDepth/2+1),
        new THREE.Vector3(0,0,-cubeDepth/2+1),
        new THREE.Vector3(40,-10,-cubeDepth/2+1)
    ];

    // Side wall icons with rotation
    const sideIcons = [
        {pos:new THREE.Vector3(-cubeWidth/2+1,30,-100), rotY:Math.PI/2},
        {pos:new THREE.Vector3(-cubeWidth/2+1,-20,-50), rotY:Math.PI/2},
        {pos:new THREE.Vector3(cubeWidth/2-1,10,-80), rotY:-Math.PI/2},
        {pos:new THREE.Vector3(cubeWidth/2-1,-15,-120), rotY:-Math.PI/2}
    ];

    const allIcons = backIcons.map(p=>({pos:p, rotY:0})).concat(sideIcons);

    allIcons.forEach(data=>{
        const iconGeo = new THREE.PlaneGeometry(35,35);
        const iconMat = new THREE.MeshStandardMaterial({
            map:iconTexture, transparent:true, metalness:0.85, roughness:0.05,
            emissive:0x33ccff, emissiveIntensity:1.2
        });
        const icon = new THREE.Mesh(iconGeo, iconMat);
        icon.position.copy(data.pos);
        icon.rotation.y = data.rotY;
        icon.userData.rotY = data.rotY;
        scene.add(icon);
        icons.push(icon);

        // subtle glow
        const glowMat = new THREE.MeshBasicMaterial({
            color:0x33ccff, transparent:true, opacity:0.2, blending:THREE.AdditiveBlending
        });
        const glow = new THREE.Mesh(new THREE.PlaneGeometry(40,40), glowMat);
        glow.position.copy(data.pos);
        glow.rotation.y = data.rotY;
        scene.add(glow);
        icon.userData.glow = glow;
    });

    // Input
    function startTouch(x,y){ touching=true; lastTouch={x,y,time:performance.now()}; }
    function moveTouch(x,y){
        if(!touching) return;
        const now = performance.now();
        let vx = (lastTouch.x - x)/(now-lastTouch.time)*1.5;
        let vy = (lastTouch.y - y)/(now-lastTouch.time)*1.5;
        velocity.x = THREE.MathUtils.clamp(vx,-maxVelocity,maxVelocity);
        velocity.y = THREE.MathUtils.clamp(vy,-maxVelocity,maxVelocity);
        lastTouch={x,y,time:now};
    }

    window.addEventListener("touchstart", e=>startTouch(e.touches[0].clientX,e.touches[0].clientY));
    window.addEventListener("touchmove", e=>moveTouch(e.touches[0].clientX,e.touches[0].clientY));
    window.addEventListener("touchend", ()=>{touching=false;});
    window.addEventListener("mousedown", e=>startTouch(e.clientX,e.clientY));
    window.addEventListener("mousemove", e=>moveTouch(e.clientX,e.clientY));
    window.addEventListener("mouseup", ()=>{touching=false;});

    // Click icons
    window.addEventListener('click', event=>{
        mouse.x = (event.clientX/window.innerWidth)*2-1;
        mouse.y = -(event.clientY/window.innerHeight)*2+1;
        raycaster.setFromCamera(mouse,camera);
        const intersects = raycaster.intersectObjects(icons);
        if(intersects.length>0){
            const icon = intersects[0].object;
            audio.currentTime=0; audio.play();

            if(activeIcon !== icon){
                activeIcon = icon;
                const offset = new THREE.Vector3(0,0,75);
                camTarget.copy(icon.position).add(offset);
                lookTarget.copy(icon.position);

                // Sidewall icons flip
                if(Math.abs(icon.userData.rotY) > 0.01){
                    icon.userData.rotBefore = icon.rotation.y;
                    icon.rotation.y = 0; // face camera
                }

            } else {
                // Deselect
                if(Math.abs(icon.userData.rotY) > 0.01){
                    icon.rotation.y = icon.userData.rotBefore;
                }
                activeIcon = null;
                camTarget.copy(defaultCamPos);
                lookTarget.copy(defaultLookAt);
            }
        }
    });

    window.addEventListener("resize", ()=>{
        camera.aspect=window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

function animate(){
    requestAnimationFrame(animate);

    // Ball physics
    ball.position.add(velocity);
    velocity.multiplyScalar(friction);
    if(ball.position.x>xLimit){ball.position.x=xLimit; velocity.x*=-0.5;}
    if(ball.position.x<-xLimit){ball.position.x=-xLimit; velocity.x*=-0.5;}
    if(ball.position.y>yLimit){ball.position.y=yLimit; velocity.y*=-0.5;}
    if(ball.position.y<-yLimit){ball.position.y=-yLimit; velocity.y*=-0.5;}

    // Camera follow ball if no icon active
    if(!activeIcon){
        const ballCamOffset = new THREE.Vector3(0,0,150);
        camTarget.lerp(ball.position.clone().add(ballCamOffset),0.05);
        lookTarget.lerp(ball.position,0.05);
    }

    // Smooth camera movement
    camera.position.lerp(camTarget, camSmooth);
    const currentLook = new THREE.Vector3().lerpVectors(camera.getWorldDirection(new THREE.Vector3()).add(camera.position), lookTarget, camSmooth);
    camera.lookAt(currentLook);

    renderer.render(scene,camera);
}
</script>
</body>
</html>
